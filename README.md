###### Java OCP 17 Exam
<details>
  <summary>Chapter 1: Building Blocks 1</summary>

- **Learning about the Environment 2**
- Major Components of Java 2
- Downloading a JDK 3
- **Understanding the Class Structure 4**
- Fields and Methods 4
- Comments 5
- Classes and Source Files 7
- **Writing a main() Method 8**
- Creating a main() Method 8
- Passing Parameters to a Java Program 9
- **Understanding Package Declarations and Imports 11**
- Packages 12
- Wildcards 13
- Redundant Imports 13
- Naming Conflicts 15
- Creating a New Package 16
- Compiling and Running Code with Packages 16
- Compiling to Another Directory 18
- Compiling with JAR Files 20
- Creating a JAR File 20
- Ordering Elements in a Class 21
- **Creating Objects 23**
- Calling Constructors 23
- Reading and Writing Member Fields 24
- Executing Instance Initializer Blocks 24
- Following the Order of Initialization 25
- **Understanding Data Types 26**
- Using Primitive Types 27
- Using Reference Types 29
- Distinguishing between Primitives and Reference Types 30
- Creating Wrapper Classes 31
- Defining Text Blocks 32
- **Declaring Variables 34**
- Identifying Identifiers 35
- Declaring Multiple Variables 36
- **Initializing Variables 38**
- Creating Local Variables 38
- Passing Constructor and Method Parameters 40
- Defining Instance and Class Variables 41
- Inferring the Type with var 41
- **Managing Variable Scope 45**
- Limiting Scope 45
- Tracing Scope 46
- Applying Scope to Classes 47
- Reviewing Scope 48
- **Destroying Objects 48**
- Understanding Garbage Collection 48
- Tracing Eligibility 49
- **Summary 51**
- **Exam Essentials 52**
- **Review Questions 54**
</details>

<details>
  <summary>Chapter 2: Operators 65</summary>

- **Understanding Java Operators 66**
- Types of Operators 66
- Operator Precedence 67
- **Applying Unary Operators 69**
- Complement and Negation Operators 70
- Increment and Decrement Operators 71
- **Working with Binary Arithmetic Operators 72**
- Arithmetic Operators 72
- Numeric Promotion 75
- **Assigning Values 77**
- Assignment Operator 77
- Casting Values 77
- Compound Assignment Operators 81
- Return Value of Assignment Operators 82
- **Comparing Values 83**
- Equality Operators 83
- Relational Operators 84
- Logical Operators 87
- Conditional Operators 88
- **Making Decisions with the Ternary Operator 90**
- **Summary 92**
- **Exam Essentials 92**
- **Review Questions 94**
</details>

<details>
  <summary>Chapter 3: Making Decisions 101</summary>

- **Creating Decision - Making Statements 102**
- Statements and Blocks 102
- The if Statement 103
- The else Statement 104
- Shortening Code with Pattern Matching 106
- **Applying switch Statements 110**
- The switch Statement 110
- The switch Expression 115
- **Writing while Loops 121**
- The while Statement 121
- The do/while Statement 123
- Infinite Loops 123
- **Constructing for Loops 124**
- The for Loop 124
- The for- each Loop 129
- **Controlling Flow with Branching 131**
- Nested Loops 131
- Adding Optional Labels 132
- The break Statement 133
- The continue Statement 135
- The return Statement 137
- Unreachable Code 138
- Reviewing Branching 139
- **Summary 139**
- **Exam Essentials 140**
- **Review Questions 142**
</details>

<details>
  <summary>Chapter 4: Core APIs 155</summary>

- **Creating and Manipulating Strings 156**
- Concatenating 157
- Important String Methods 158
- Method Chaining 169
- **Using the StringBuilder Class 170**
- Mutability and Chaining 171
- Creating a StringBuilder 172
- Important StringBuilder Methods 172
- **Understanding Equality 175**
- Comparing equals() and == 175
- The String Pool 176
- **Understanding Arrays 178**
- Creating an Array of Primitives 179
- Creating an Array with Reference Variables 180
- Using an Array 182
- Sorting 183
- Searching 184
- Comparing 185
- Using Methods with Varargs 187
- Working with Multidimensional Arrays 188
- **Calculating with Math APIs 190**
- Finding the Minimum and Maximum 190
- Rounding Numbers 191
- Determining the Ceiling and Floor 191
- Calculating Exponents 192
- Generating Random Numbers 192
- **Working with Dates and Times 192**
- Creating Dates and Times 193
- Manipulating Dates and Times 197
- Working with Periods 199
- Working with Durations 202 Period vs. Duration 204
- Working with Instants 205
- Accounting for Daylight Saving Time 206
- **Summary 208**
- **Exam Essentials 209**
- **Review Questions 210**
</details>

<details>
  <summary>Chapter 5: Methods 219</summary>

- **Designing Methods 220**
- Access Modifiers 221
- Optional Specifiers 222
- Return Type 224
- Method Name 226
- Parameter List 226
- Method Signature 227
- Exception List 227
- Method Body 228
- **Declaring Local and Instance Variables 228**
- Local Variable Modifiers 229
- Effectively Final Variables 230
- Instance Variable Modifiers 231
- **Working with Varargs 232**
- Creating Methods with Varargs 232
- Calling Methods with Varargs 233
- Accessing Elements of a Vararg 234
- Using Varargs with Other Method Parameters 234
- **Applying Access Modifiers 235**
- Private Access 235
- Package Access 236
- Protected Access 237
- Public Access 242
- Reviewing Access Modifiers 242
- **Accessing static Data 243**
- Designing static Methods and Variables 243
- Accessing a static Variable or Method 244
- Class vs. Instance Membership 245 Static Variable Modifiers 248 Static Initializers 250 Static Imports 251
- **Passing Data among Methods 253**
- Passing Objects 253
- Returning Objects 255
- Autoboxing and Unboxing Variables 256
- **Overloading Methods 258**
- Reference Types 259
- Primitives 260
- Autoboxing 261
- Arrays 261
- Varargs 261
- Putting It All Together 262
- **Summary 263**
- **Exam Essentials 264**
- **Review Questions 265**
</details>

<details>
  <summary>Chapter 6: Class Design 275</summary>

- **Understanding Inheritance 276**
- Declaring a Subclass 276
- Class Modifiers 278
- Single vs. Multiple Inheritance 279
- Inheriting Object 279
- **Creating Classes 281**
- Extending a Class 281
- Applying Class Access Modifiers 282
- Accessing the this Reference 283
- Calling the super Reference 284
- **Declaring Constructors 286**
- Creating a Constructor 286
- The Default Constructor 287
- Calling Overloaded Constructors with this() 289
- Calling Parent Constructors with super() 292
- **Initializing Objects 297**
- Initializing Classes 297
- Initializing final Fields 298
- Initializing Instances 300
- **Inheriting Members 304**
- Overriding a Method 305
- Redeclaring private Methods 311
- Hiding Static Methods 311
- Hiding Variables 313
- Writing final Methods 314
- **Creating Abstract Classes 315**
- Introducing Abstract Classes 315
- Declaring Abstract Methods 317
- Creating a Concrete Class 318
- Creating Constructors in Abstract Classes 320
- Spotting Invalid Declarations 321
- **Creating Immutable Objects 323**
- Declaring an Immutable Class 323
- Performing a Defensive Copy 325
- **Summary 326**
- **Exam Essentials 327**
- **Review Questions 330**
</details>


<details>
  <summary>Chapter 7: Beyond Classes 345</summary>

- **Implementing Interfaces 346**
- Declaring and Using an Interface 346
- Extending an Interface 348
- Inheriting an Interface 349
- Inserting Implicit Modifiers 351
- Declaring Concrete Interface Methods 353
- **Working with Enums 361**
- Creating Simple Enums 361
- Using Enums in switch Statements 363
- Adding Constructors, Fields, and Methods 364
- **Sealing Classes 367**
- Declaring a Sealed Class 367
- Compiling Sealed Classes 368
- Specifying the Subclass Modifier 369
- Omitting the permits Clause 370
- Sealing Interfaces 372
- Reviewing Sealed Class Rules 372
- **Encapsulating Data with Records 373**
- Understanding Encapsulation 374
- Applying Records 375
- Understanding Record Immutability 377
- Declaring Constructors 378
- Customizing Records 381
- **Creating Nested Classes 382**
- Declaring an Inner Class 382
- Creating a static Nested Class 386
- Writing a Local Class 387
- Defining an Anonymous Class 389
- Reviewing Nested Classes 391
- **Understanding Polymorphism 392**
- Object vs. Reference 393
- Casting Objects 395
- The instanceof Operator 397
- Polymorphism and Method Overriding 397
- Overriding vs. Hiding Members 399
- **Summary 401**
- **Exam Essentials 402**
- **Review Questions 404**
</details>

<details>
  <summary>Chapter 8: Lambdas and Functional Interfaces 419</summary>

- **Writing Simple Lambdas 420**
- Looking at a Lambda Example 420
- Learning Lambda Syntax 422
- **Coding Functional Interfaces 426**
- Defining a Functional Interface 426
- Adding Object Methods 427
- **Using Method References 429**
- Calling static Methods 430
- Calling Instance Methods on a Particular Object 430
- Calling Instance Methods on a Parameter 432
- Calling Constructors 433
- Reviewing Method References 433
- **Working with Built- in Functional Interfaces 434**
- Implementing Supplier 435
- Implementing Consumer and BiConsumer 436
- Implementing Predicate and BiPredicate 438
- Implementing Function and BiFunction 439
- Implementing UnaryOperator and BinaryOperator 440
- Checking Functional Interfaces 441
- Using Convenience Methods on Functional Interfaces 442
- Learning the Functional Interfaces for Primitives 443
- **Working with Variables in Lambdas 445**
- Listing Parameters 446
- Using Local Variables inside a Lambda Body 448
- Referencing Variables from the Lambda Body 449
- **Summary 450**
- **Exam Essentials 451**
- **Review Questions 452**
</details>


<details>
  <summary>Chapter 9: Collections and Generics 463</summary>

- **Using Common Collection APIs 464**
- Using the Diamond Operator 465
- Adding Data 466
- Removing Data 466
- Counting Elements 467
- Clearing the Collection 467
- Check Contents 468
- Removing with Conditions 468
- Iterating 469
- Determining Equality 470
- **Using the List Interface 471**
- Comparing List Implementations 472
- Creating a List with a Factory 472
- Creating a List with a Constructor 473
- Working with List Methods 474
- Converting from List to an Array 476
- **Using the Set Interface 477**
- Comparing Set Implementations 477
- Working with Set Methods 478
- **Using the Queue and Deque Interfaces 479**
- Comparing Deque Implementations 480
- Working with Queue and Deque Methods 480
- **Using the Map Interface 483**
- Comparing Map Implementations 484
- Working with Map Methods 484
- Calling Basic Methods 486
- Iterating through a Map 487
- Getting Values Safely 487
- Replacing Values 488
- Putting if Absent 488
- Merging Data 488
- **Comparing Collection Types 490**
- **Sorting Data 492**
- Creating a Comparable Class 492
- Comparing Data with a Comparator 496
- Comparing Comparable and Comparator 497
- Comparing Multiple Fields 498
- Sorting and Searching 500
- Sorting a List 503
- **Working with Generics 503**
- Creating Generic Classes 504
- Understanding Type Erasure 506
- Implementing Generic Interfaces 509
- Writing Generic Methods 510
- Creating a Generic Record 512
- Bounding Generic Types 512
- Putting It All Together 517
- **Summary 519**
- **Exam Essentials 520**
- **Review Questions 521**
</details>

<details>
  <summary>Chapter 10: Streams 531</summary>

- **Returning an Optional 532**
- Creating an Optional 533
- Dealing with an Empty Optional 534
- **Using Streams 536**
- Understanding the Pipeline Flow 536
- Creating Stream Sources 539
- Using Common Terminal Operations 541
- Using Common Intermediate Operations 549
- Putting Together the Pipeline 553
- **Working with Primitive Streams 557**
- Creating Primitive Streams 557
- Mapping Streams 560
- Using Optional with Primitive Streams 562
- Summarizing Statistics 564
- **Working with Advanced Stream Pipeline Concepts 565**
- Linking Streams to the Underlying Data 565
- Chaining Optionals 566
- Using a Spliterator 569
- Collecting Results 570
- **Summary 578**
- **Exam Essentials 579**
- **Review Questions 581**
</details>


<details>
  <summary>Chapter 11: Exceptions and Localization 591</summary>

- **Understanding Exceptions 592**
- The Role of Exceptions 592
- Understanding Exception Types 593
- Throwing an Exception 596
- Calling Methods That Throw Exceptions 598
- Overriding Methods with Exceptions 599
- Printing an Exception 600
- **Recognizing Exception Classes 600**
- RuntimeException Classes 601
- Checked Exception Classes 604
- Error Classes 605
- **Handling Exceptions 605**
- Using try and catch Statements 606
- Chaining catch Blocks 607
- Applying a Multi- catch Block 609
- Adding a finally Block 611
- **Automating Resource Management 615**
- Introducing Try- with- Resources 615
- Basics of Try- with- Resources 616
- Applying Effectively Final 620
- Understanding Suppressed Exceptions 621
- **Formatting Values 624**
- Formatting Numbers 624
- Formatting Dates and Times 625
- Customizing the Date/Time Format 626
- **Supporting Internationalization and Localization 629**
- Picking a Locale 630
- Localizing Numbers 632
- Localizing Dates 637
- Specifying a Locale Category 638
- **Loading Properties with Resource Bundles 639**
- Creating a Resource Bundle 640
- Picking a Resource Bundle 641
- Selecting Resource Bundle Values 643
- Formatting Messages 645
- Using the Properties Class 645
- **Summary 646**
- **Exam Essentials 647**
- **Review Questions 648**
</details>


<details>
  <summary>Chapter 12: Modules 661</summary>

- **Introducing Modules 662**
- Exploring a Module 663
- Benefits of Modules 664
- **Creating and Running a Modular Program 664**
- Creating the Files 665
- Compiling Our First Module 666
- Running Our First Module 668
- Packaging Our First Module 669
- **Updating Our Example for Multiple Modules 669**
- Updating the Feeding Module 670
- Creating a Care Module 670
- Creating the Talks Module 672
- Creating the Staff Module 674
- **Diving into the Module Declaration 675**
- Exporting a Package 676
- Requiring a Module Transitively 677
- Opening a Package 679
- **Creating a Service 680**
- Declaring the Service Provider Interface 681
- Creating a Service Locator 682
- Invoking from a Consumer 684
- Adding a Service Provider 685
- Reviewing Directives and Services 686
- **Discovering Modules 687**
- Identifying Built- in Modules 688
- Getting Details with java 690
- Describing with jar 693
- Learning about Dependencies with jdeps 693
- Using the -- jdk- internals Flag 695
- Using Module Files with jmod 696
- Creating Java Runtimes with jlink 696
- Reviewing Command- Line Options 697
- **Comparing Types of Modules 700**
- Named Modules 701
- Automatic Modules 701
- Unnamed Modules 704
- Reviewing Module Types 704
- **Migrating an Application 704**
- Determining the Order 705
- Exploring a Bottom- Up Migration Strategy 706
- Exploring a Top- Down Migration Strategy 707
- Splitting a Big Project into Modules 709
- Failing to Compile with a Cyclic Dependency 709
- **Summary 711**
- **Exam Essentials 712**
- **Review Questions 713**
</details>

<details>
  <summary>Chapter 13: Concurrency 721</summary>

- **Introducing Threads 722**
- Understanding Thread Concurrency 723
- Creating a Thread 724
- Distinguishing Thread Types 725
- Managing a Thread’s Life Cycle 727
- Polling with Sleep 727
- Interrupting a Thread 729
- **Creating Threads with the Concurrency API 730**
- Introducing the Single- Thread Executor 730
- Shutting Down a Thread Executor 731
- Submitting Tasks 732
- Waiting for Results 733
- Scheduling Tasks 737
- Increasing Concurrency with Pools 739
- **Writing Thread- Safe Code 740**
- Understanding Thread- Safety 740
- Accessing Data with volatile 741
- Protecting Data with Atomic Classes 742
- Improving Access with Synchronized Blocks 744
- Synchronizing on Methods 746
- Understanding the Lock Framework 747
- Orchestrating Tasks with a CyclicBarrier 751
- **Using Concurrent Collections 754**
- Understanding Memory Consistency Errors 754
- Working with Concurrent Classes 755
- Obtaining Synchronized Collections 757
- **Identifying Threading Problems 758**
- Understanding Liveness 758
- Managing Race Conditions 761
- **Working with Parallel Streams 761**
- Creating Parallel Streams 762
- Performing a Parallel Decomposition 762
- Processing Parallel Reductions 764
- **Summary 770**
- **Exam Essentials 770**
- **Review Questions 772**
</details>


<details>
  <summary>Chapter 14: I/O 785</summary>

- **Referencing Files and Directories 786**
- Conceptualizing the File System 786
- Creating a File or Path 789
- **Operating on File and Path 793**
- Using Shared Functionality 793
- Handling Methods That Declare IOException 797
- Providing NIO.2 Optional Parameters 797
- Interacting with NIO.2 Paths 799
- Creating, Moving, and Deleting Files and Directories 805
- Comparing Files with isSameFile() and mismatch() 809
- **Introducing I/O Streams 811**
- Understanding I/O Stream Fundamentals 811
- Learning I/O Stream Nomenclature 812
- **Reading and Writing Files 817**
- Using I/O Streams 817
- Enhancing with Files 820
- Combining with newBufferedReader() and newBufferedWriter() 822
- Reviewing Common Read and Write Methods 823
- **Serializing Data 824**
- Applying the Serializable Interface 825
- Marking Data transient 827
- Ensuring That a Class Is Serializable 827
- Storing Data with ObjectOutputStream and ObjectInputStream 828
- Understanding the Deserialization Creation Process 830
- **Interacting with Users 832**
- Printing Data to the User 832
- Reading Input as an I/O Stream 833
- Closing System Streams 833
- Acquiring Input with Console 834
- **Working with Advanced APIs 837**
- Manipulating Input Streams 838
- Discovering File Attributes 840
- Traversing a Directory Tree 843
- Searching a Directory 847
- **Review of Key APIs 848**
- **Summary 850**
- **Exam Essentials 851**
- **Review Questions 852**
</details>


<details>
  <summary>Chapter 15: JDBC 863</summary>

- **Introducing Relational Databases and SQL 864**
- Identifying the Structure of a Relational Database 866
- Writing Basic SQL Statements 867
- **Introducing the Interfaces of JDBC 868**
- **Connecting to a Database 870**
- Building a JDBC URL 870
- Getting a Database Connection 871
- **Working with a PreparedStatement 873**
- Obtaining a PreparedStatement 874
- Executing a PreparedStatement 875
- Working with Parameters 878
- Updating Multiple Records 881
- **Getting Data from a ResultSet 882**
- Reading a ResultSet 882
- Getting Data for a Column 885
- Using Bind Variables 887
- **Calling a CallableStatement 887**
- Calling a Procedure without Parameters 888
- Passing an IN Parameter 889
- Returning an OUT Parameter 889
- Working with an INOUT Parameter 890
- Comparing Callable Statement Parameters 891
- Using Additional Options 891
- **Controlling Data with Transactions 892**
- Committing and Rolling Back 892
- Bookmarking with Savepoints 894
- Reviewing Transaction APIs 895
- **Closing Database Resources 895**
- **Summary 897**
- **Exam Essentials 898**
- **Review Questions 900**
</details>